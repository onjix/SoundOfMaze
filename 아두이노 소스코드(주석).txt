#include <SoftwareSerial.h>
SoftwareSerial BTSerial(2, 3); // 소프트웨어 시리얼 포트(RX, TX)
int i=6, j=0; //미로 배열의 시작 i, j값
char mv; // 조이스틱 방향 입력을 위한 변수
int s; //스테이지 구분을 위한 변수
int maze1[7][7] = { //스테이지1
 {1, 1, 1, 1, 1, 1, 1},
 {1, 1, 1, 1, 1, 1, 1},
 {1, 1, 1, 1, 1, 1, 1},
 {1, 1, 0, 1, 1, 1, 1},
 {1, 1, 0, 0, 0, 1, 1},
 {1, 0, 0, 1, 0, 1, 1},
 {0, 0, 1, 1, 2, 1, 1}// 미로 시작점[6, 0]
};
int maze2[7][7] = { //스테이지2
 {1, 0, 1, 1, 1, 1, 2},
 {1, 0, 0, 0, 0, 0, 0},
 {1, 0, 1, 1, 1, 1, 1},
 {1, 0, 0, 0, 1, 1, 1},
 {1, 1, 1, 0, 0, 0, 1},
 {1, 1, 0, 0, 1, 1, 1},
 {0, 0, 0, 1, 1, 1, 1}  //미로 시작점[6, 0]
};
void setup(){
 Serial.begin(9600); // 컴퓨터와의 시리얼 통신 초기화
 BTSerial.begin(9600); // 블루투스 모듈과의 시리얼 통신 초기화
 pinMode(8, INPUT_PULLUP);
 pinMode(A0, INPUT);
 pinMode(A1, INPUT);
}
int check() { //스테이지를 고르는 함수
 if (BTSerial.available() > 0) {
   s = BTSerial.read(); //앱인벤터 버튼클릭으로 s값 입력
 }
 return s; //선택된 스테이지 값 리턴
}
char movecheck(int x, int y) { //조이스틱 상하좌우 및 대각선과 가운데 방향 구분
 if ((x >= 450 && x <= 550) &&  (y >= 450 && y <= 550)) {
   mv = 's';
 }
 //1 대각선방향
 else if ((x >= 0 && x < 450) &&  (y >= 0 && y < 450)) {
   mv = 's';
 }
 //2 대각선방향
 else if ((x >= 0 && x < 450) &&  (y > 550 && y <= 1024)) {
   mv = 's';
 }
 //3 대각선방향
 else if ((x > 550 && x <= 1023) &&  (y >= 0 && y < 450)) {
   mv = 's';
 }
 //4 대각선방향
 else if ((x > 550 && x <= 1023) &&  (y > 550 && y <= 1024)) {
   mv = 's';
 }
 //Up 상
 else if (x >= 450 && x <= 550 &&  y >= 0 && y <= 500) {
   mv = 'u';
 }
 //Down 하
 else if (x >= 450 && x <= 550 &&  y > 550 && y <= 1024) {
   mv = 'd';
 }
 //Right 좌
 else if (x > 550 && x <= 1024 &&  y >= 450 && y <= 550) {
   mv = 'r';
 }
 //Left 우
 else if (x >= 0 && x < 450 &&  y >= 450 && y <= 550) {
   mv = 'l';
 }
 return mv; //해당 방향을 리턴
}
int go_move(int maze[][7], char mv) { //미로배열 안의 이동 함수
 int done = 2; //게임종료
 int go = 3; //이동
 int wall = 4; //벽
 if (mv == 'u') { //조이스틱 입력이 상(up)일 때
   if (maze[i - 1][j] == 0) { //이동하려는 배열의 값이 이동 가능한 값(0)일 때
     Serial.println("위로 이동하였습니다."); //시리얼모니터 출력
     i--;  //배열 i값을 감소하며 이동
     if(i < 0) { //이동하려는 배열의 값이 테두리일 때==벽과 부딪혔을 때
       Serial.println("위 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
       i = 0; //배열 i값은 배열의 최소 값으로 입력하며 이동하지 않음
       return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
     }
     return go; //앱인벤터 통신으로 이동하는 효과음 출력을 위한 리턴
   }
   else if (maze[i - 1][j] == 2) { //이동하려는 배열의 값이 최종 도착점의 값(2)일때
     Serial.println("게임이 종료되었습니다."); //시리얼모니터 출력
     i--; //배열 i값을 감소하며 이동
     return done; //앱인벤터 통신으로 성공하는 효과음 출력을 위한 리턴
   }
   else { //이동하려는 배열의 값이 이동 가능한 값(0)이 아닐 때==벽과 부딪혔을 때
    Serial.println("위 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
    return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
   }
 }
 else if (mv == 'd') { //조이스틱 입력이 하(down)일 때
   if (maze[i + 1][j] == 0) { //이동하려는 배열의 값이 이동 가능한 값(0)일 때
     Serial.println("아래로 이동하였습니다."); //시리얼모니터 출력
     i++; //배열 i값을 증가하며 이동
     if(i > 6) { //이동하려는 배열의 값이 테두리일 때==벽과 부딪혔을 때
       Serial.println("아래 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
       i = 6; //배열 i값은 배열의  최대 값으로 입력하며 이동하지 않음
       return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
     }
     return go; //앱인벤터 통신으로 이동하는 효과음 출력을 위한 리턴
   }
   else if (maze[i + 1][j] == 2) { //이동하려는 배열의 값이 최종 도착점의 값(2)일때
     i++; //배열 i값을 증가하며 이동
     Serial.println("게임이 종료되었습니다."); //시리얼모니터 출력
     return done; //앱인벤터 통신으로 성공하는 효과음 출력을 위한 리턴
   }
   else { //이동하려는 배열의 값이 이동 가능한 값(0)이 아닐 때==벽과 부딪혔을 때
    Serial.println("아래 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
    return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
   }
 }
 else if (mv == 'r') { //조이스틱 입력이 우(right)일 때
   if (maze[i][j + 1] == 0) { //이동하려는 배열의 값이 이동 가능한 값(0)일 때
     Serial.println("오른쪽으로 이동하였습니다."); //시리얼모니터 출력
     j++; //배열 j값을 증가하며 이동
     if(j > 6) { //이동하려는 배열의 값이 테두리일 때==벽과 부딪혔을 때
       Serial.println("오른쪽 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
       j = 6; //배열 j값은 배열의 최대 값으로 입력하며 이동하지 않음
       return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
     }
     return go; //앱인벤터 통신으로 이동하는 효과음 출력을 위한 리턴
   }
   else if (maze[i][j + 1] == 2) { //이동하려는 배열의 값이 최종 도착점의 값(2)일때
     Serial.println("게임이 종료되었습니다."); //시리얼모니터 출력
     j++; //배열 j값을 증가하며 이동
     return done; //앱인벤터 통신으로 성공하는 효과음 출력을 위한 리턴
   }
   else { //이동하려는 배열의 값이 이동 가능한 값(0)이 아닐 때==벽과 부딪혔을 때
    Serial.println("오른쪽 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
    return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
   }
 }
 else if (mv == 'l') {  //조이스틱 입력이 좌(left)일 때
   if (maze[i][j - 1] == 0) { //이동하려는 배열의 값이 이동 가능한 값(0)일 때
     Serial.println("왼쪽으로 이동하였습니다."); //시리얼모니터 출력
     j--;  //배열 j값을 감소하며 이동
     if(j < 0) { //이동하려는 배열의 값이 테두리일 때==벽과 부딪혔을 때
       Serial.println("왼쪽 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
       j = 0; //배열 j값은 배열의 최소 값으로 입력하며 이동하지 않음
       return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
     }
     return go; //앱인벤터 통신으로 이동하는 효과음 출력을 위한 리턴
   }
   else if (maze[i][j - 1] == 2) { //이동하려는 배열의 값이 최종 도착점의 값(2)일때
     Serial.println("게임이 종료되었습니다."); //시리얼모니터 출력
     j--; //배열 j값을 감소하며 이동
     return done; //앱인벤터 통신으로 성공하는 효과음 출력을 위한 리턴
   }
   else { //이동하려는 배열의 값이 이동 가능한 값(0)이 아닐 때==벽과 부딪혔을 때
    Serial.println("왼쪽 벽과 부딪혀 다시 되돌아왔습니다."); //시리얼모니터 출력
    return wall; //앱인벤터 통신으로 벽과 부딪히는 효과음 출력을 위한 리턴
   }
 }
 else if (mv == 's') { //조이스틱 입력이 상하좌우 방향이 아닌 대각선 방향 및 제자리일 때
   i = i; //배열 i값은 변하지 않으며 이동하지 않음
   j = j; //배열 j값은 변하지 않으며 이동하지 않음
 }
 return 0; //조이스틱 입력이 상하좌우 방향이 아닌 대각선 방향 및 제자리일 때 0리턴
}
void getsound(int f) { //앱인벤터 통신을 통해 효과음 출력을 위한 함수
 if (f == 2) { //2(done) 성공시
   BTSerial.write("success"); //블루투스 통신으로 앱인벤터에 "success" 송신
   s=0; //스테이지 초기화
 }
 if (f == 3) { //3(go) 이동시
   BTSerial.write("move"); //블루투스 통신으로 앱인벤터에 "move" 송신
 }
 if (f == 4) { //4(wall) 벽과 부딪힐 시
   BTSerial.write("wall");//블루투스 통신으로 앱인벤터에 "wall" 송신
 }
}
void getprint() { //시리얼 모니터를 통한 현재 미로 배열의 위치 출력을 위한 함수
 Serial.print(" 현재: 미로[");
 Serial.print(i); //미로의 세로(i)위치
 Serial.print("],[");
 Serial.print(j); //미로의 가로(j)위치
 Serial.println("]");
}
void loop() {
 int x; //조이스틱의 x값을 저장하기 위한 변수
 int y; //조이스틱의 y값을 저장하기 위한 변수
 int f; //go_move 함수를 통해 done, go, wall 중 해당하는 값을 리턴받기 위한 변수
 s = check();  //check 함수를 통해 스테이지를 선택
 if(s == 0) { //s가 0일땐 i,j값을 초기값으로 설정
   i=6;
   j=0;
 }
 else if(s == 1) { //s가 1일때 스테이지 1실행
   x = analogRead(A0); //조이스틱 x값 입력
   y = analogRead(A1); //조이스틱  y값 입력
   mv = movecheck(x, y); //movecheck 함수를 통해 변수 mv에 방향 입력
   f = go_move(maze1, mv); //go_move함수를 통해 maze1(스테이지1) 배열 안에서 mv의 방향 값으로 이동하며 결과 값을 변수 f에 입력
   getsound(f); //변수 f에 입력된 go_move의 결과 값의 해당 효과음을 실행하기 위해 getsound함수를 통해 블루투스 통신하여 앱인벤터로 전송
   getprint(); //getprint함수를 사용해 시리얼모니터에 미로 배열의 현재 위치 출력
   delay(1000);
 }
 else if(s == 2) {//s가 2일때 스테이지 2실행
   x = analogRead(A0); //조이스틱 x값 입력
   y = analogRead(A1); //조이스틱  y값 입력
   mv = movecheck(x, y); //movecheck 함수를 통해 변수 mv에 방향 입력
   f = go_move(maze2, mv);  //go_move함수를 통해 maze2(스테이지2) 배열 안에서 mv의 방향 값으로 이동하며 결과 값을 변수 f에 입력
   getsound(f); //변수 f에 입력된 go_move의 결과 값의 해당 효과음을 실행하기 위해 getsound함수를 통해 블루투스 통신하여 앱인벤터로 전송
   getprint(); //getprint함수를 사용해 시리얼모니터에 미로 배열의 현재 위치 출력
   delay(1000);
 }
}